var searchIndex = {};
searchIndex['list'] = {"items":[[0,"","list","[OCaml's List module](http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html) in rust!"],[1,"RefItems","",""],[1,"MoveItems","",""],[2,"List","","Rust implementation of OCaml's `'a list`."],[12,"Nil","","",0],[12,"Cons","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"length","","Return the length (number of elements) of the given list.",0],[10,"hd","","Return the first element of the given list. Return `None` if the list is\nempty.",0],[10,"tl","","Return the given list without its first element. Return `None` if the\nlist is empty.",0],[10,"nth","","Return the `n`-th element of the given list. The first element (head of\nthe list) is at position 0. Return `None` if the list is too short.",0],[10,"rev","","List reversal.",0],[10,"append","","Catenate two lists.",0],[10,"rev_append","","`l1.rev_append(l2)` reverses `l1` and concatenates it to `l2`. This is\nequivalent to `l1.rev().append(l2)`.",0],[10,"concat","","Concatenate a list of lists. The elements of the argument are all\nconcatenated together (in the same order) to give the result.",0],[10,"flatten","","Same as `concat`.",0],[10,"iter","","`list![a1, ..., an].iter(f)` applies `f` in turn to `a1, ..., an`. It is\nequivalent to `{f(a1); f(a2); ...; f(an);}`.",0],[10,"iteri","","Same as `iter`, but the function is applied to the index of the elements\nas first argument (counting from 0), and the element itself as second\nargument.",0],[10,"map","","`list![a1, ..., an].map(f)` applies function `f` to `a1, ..., an`, and\nbuilds the list `list![f(a1), ..., f(an)]` with the results returned by\n`f`.",0],[10,"mapi","","Same as `map`, but the function is applied to the index of the elements\nas first argument (counting from 0), and the element itself as second\nargument.",0],[10,"rev_map","","`l.rev_map(f)` gives the same results as `l.rev().map(f)`.",0],[10,"fold_left","","`list![b1, ..., bn].fold_left(f, a)` is `f (... (f ( f a b1) b2) ... )\nbn`.",0],[10,"fold_right","","`list![a1, ..., an].fold_right(f, b)` is `f a1 (f a2 (... (f an b) ...))`.",0],[10,"iter2","","`list![a1, ..., an].iter2(f, list![b1, ..., bn])` calls in turn\n`f(a1, b1), ..., f(an, bn)`. Return `None` if the two lists have\ndifferent lengths.",0],[10,"map2","","`list![a1, ..., an].map2(f, list![b1, ..., bn])` is\n`list![f(a1, b1), ..., f(an, bn)]`. Return `None` if the two lists have\ndifferent lengths.",0],[10,"rev_map2","","`l1.rev_map2(f, l2)` gives the same result as `l1.map2(f, l2).rev()`.",0],[10,"fold_left2","","`list![a1, ..., an].fold_left2(f, a, list![b1, ..., bn])` is\n`f (... (f (f a a1 b1) a2 b2) ...) an bn`. Return `None` if the two\nlists have different length.",0],[10,"fold_right2","","`list![a1, ..., an].fold_right2(f, a, list![b1, ..., bn])` is\n`f a1 b1 (f a2 b2 (... (f an bn a) ...))`. Return `None` if the two\nlists have different length.",0],[10,"for_all","","`list![a1, ..., an].for_all(p)` checks if all elements of the list\nsatisfy the predicate `p`. That is, it returns\n`(p(a1)) && (p(a2)) && ... && (p(an))`",0],[10,"exists","","`list![a1, ..., an].for_all(p)` checks if at least one element of the\nlist satisfies the predicate `p`. That is, it returns\n`(p(a1)) || (p(a2)) || ... || (p(an))`",0],[10,"for_all2","","Same as `List::for_all`, but for a two-argument predicate. Return `None`\nif the two lists have different lengths.",0],[10,"exists2","","Same as `List::exists`, but for a two-argument predicate. Return `None`\nif the two lists have different lengths.",0],[10,"mem","","`l.mem(a)` is true if and only if `a` is equal to an element of `l`.",0],[10,"find","","`l.find(p)` returns the first element of the list `l` that satisfies the\npredicate `p`.  Return `None` if there is no value that satisfies `p` in\nthe list `l`.",0],[10,"filter","","`l.filter(p)` returns all the elements of the list `l` that satisfy the\npredicate `p`. The order of the elements in the input list is preserved.",0],[10,"find_all","","`find_all` is another name for `filter`.",0],[10,"partition","","`l.partition(p)` returns a pair of lists `(l1, l2)` where `l1` is the\nlist of all the elements of `l` that satisfy the predicate `p`, and `l2`\nis the list of all elements of `l` that do not satisfy `p`. The order of\nthe elements in the input list is preserved.",0],[10,"assoc","","`l.assoc(a)` returns the value associated with key `x` in the list of\npairs `l`. That is, `list![..., (x, y), ...].assoc(x) == y` if `(x, y)`\nis the leftmost binding of `a` in list `l`. Return `None` if there is no\nvalue associated with `x` in the list `l`.",0],[10,"mem_assoc","","Same as `assoc`, but simple return true if a binding exists, and false\nif no bindings exist for the given key.",0],[10,"remove_assoc","","`l.remove_assoc(x)` returns the list of pairs `l` without the first pair\nwith key `x`, if any.",0],[10,"split","","Transform a list of pairs into a pair of lists: `list![(a1, b1), ...,\n(an, bn)].split()` is `(list![a1, ..., an], list![b1, ..., bn])`.",0],[10,"combine","","Transform a pair of lists into a list of pairs:\n`list![a1, ..., an].combine(list![b1, ..., bn])` is `list![(a1,b2), ...,\n(an,bn)]`. Return `None` if the two lists have different lengths.",0],[10,"sort","","Sort a list in increasing order according to a comparison function. The\ncomparison function must return 0 if the arguments compare as equal, a\npositive integer if the first is greater, and a negative integer if the\nfirst is smaller. The resulting list is sorted in increasing order.",0],[10,"stable_sort","","Same as `sort` but the sorting algorithm is guaranteed to be stable\n(i.e. elements that compare equal are kept in their original order).",0],[10,"fast_sort","","Same as `sort` or `stable_sort`, whichever is faster on typical input.",0],[10,"sort_uniq","","Same as `sort`, but also remove duplicates.",0],[10,"merge","","Merge two lists: Assuming that `l1` and `l2` are sorted according to the\ncomparison function `cmp`, `l1.merge(cmp, l2)` will return a sorted list\ncontaining all the elemnts of `l1` and `l2`. If several elements compare\nequal, the elements of `l1` will be before the elements of `l2`.",0],[10,"into_hd","","Non-borrowing implementation of `hd`.",0],[10,"into_tl","","Non-borrowing implementation of `tl`.",0],[10,"into_nth","","Non-borrowing implementation of `nth`.",0],[10,"appended","","Non-borrowing implementation of `append`.",0],[10,"rev_appended","","Non-borrowing implementation of `rev_append`.",0],[10,"concated","","Non-borrowing implementation of `concat`.",0],[10,"flattened","","Non-borrowing implementation of `flatten`.",0],[10,"itered","","Non-borrowing implementation of `iter`.",0],[10,"iteried","","Non-borrowing implementation of `iteri`.",0],[10,"mapped","","Non-borrowing implementation of `map`.",0],[10,"mapied","","Non-borrowing implementation of `mapi`.",0],[10,"rev_mapped","","Non-borrowing implementation of `rev_map`.",0],[10,"folded_left","","Non-borrowing implementation of `fold_left`.",0],[10,"folded_right","","Non-borrowing implementation of `fold_right`.",0],[10,"itered2","","Non-borrowing implementation of `iter2`.",0],[10,"mapped2","","Non-borrowing implementation of `map2`.",0],[10,"rev_mapped2","","Non-borrowing implementation of `rev_map2`.",0],[10,"folded_left2","","Non-borrowing implementation of `fold_left2`.",0],[10,"folded_right2","","Non-borrowing implementation of `fold_right2`.",0],[10,"for_alled","","Non-borrowing implementation of `for_all`.",0],[10,"into_exists","","Non-borrowing implementation of `exists`.",0],[10,"for_alled2","","Non-borrowing implementation of `for_all2`.",0],[10,"into_exists2","","Non-borrowing implementation of `exists2`.",0],[10,"memed","","Non-borrowing implementation of `mem`.",0],[10,"found","","Non-borrowing implementation of `find`.",0],[10,"filtered","","Non-borrowing implementation of `filter`.",0],[10,"found_all","","Non-borrowing implementation of `find_all`.",0],[10,"partitioned","","Non-borrowing implementation of `partition`.",0],[10,"assoced","","Non-borrowing implementation of `assoc`.",0],[10,"mem_assoced","","Non-borrowing implementation of `mem_assoc`.",0],[10,"remove_assoced","","Non-borrowing implementation of `remove_assoc`.",0],[10,"splitted","","Non-borrowing implementation of `split`.",0],[10,"combined","","Non-borrowing implementation of `combine`.",0],[10,"sorted","","Non-borrowing implementation of `sort`.",0],[10,"stable_sorted","","Non-borrowing implementation of `stable_sort`.",0],[10,"fast_sorted","","Non-borrowing implementation of `fast_sort`.",0],[10,"sorted_uniq","","Non-borrowing implementation of `sort_uniq`.",0],[10,"merged","","Non-borrowing implementation of `merge`.",0],[10,"from_iter","","",0],[10,"fmt","","```\n# #![feature(phase)]\n# #[phase(plugin, link)]\n# extern crate list;\n# use list::List;\n# use list::List::{Nil, Cons};\n# fn main() {\nlet nil: List<int> = Nil;\nassert_eq!(format!(\"{}\", nil),             \"[]\");\nassert_eq!(format!(\"{}\", list![1i]),       \"[1]\");\nassert_eq!(format!(\"{}\", list![1i, 2]),    \"[1, 2]\");\nassert_eq!(format!(\"{}\", list![1i, 2, 3]), \"[1, 2, 3]\");\n# }",0],[10,"to_iter","","",0],[10,"next","","",1],[10,"into_iter","","",0],[10,"next","","",2],[15,"list!","","Create a `list::List` containing the arguments."]],"paths":[[2,"List"],[1,"RefItems"],[1,"MoveItems"]]};
initSearch(searchIndex);
